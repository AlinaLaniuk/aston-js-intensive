console.log('1');
setTimeout(() => console.log('2'), 1);
let promiseNew = new Promise((resolve) => {
    console.log('3');
    resolve();
});
promiseNew.then(() => console.log('4'));
setTimeout(() => console.log('5'));
console.log('6');

// порядок вывода - '1' - '3' - '6' - '4' - '5' - '2'

// Порядок выполнения
// console.log('1'); // залогируется первым, синхронный код
// setTimeout(() => console.log('2'), 1);  // setTimeout выполнится синхронно, коллбек будет отдан браузеру для добавления в очередь макротасок
// let promiseNew = new Promise((resolve) => { // создание промиса - это синхронная операция. Код переданной в качестве коллбека функции исполнится синхронно. 
// console.log('3'); // залогируется после '1', так как функция, в которой "лежит" этот консоль лог выполняется синхронно
// resolve();
// });
// promiseNew.then(() => console.log('4')); // метод then - синхронный. его задача - отдать браузеру коллбек (или коллбеки), чтобы в тот момент, когда промис, к которому этот then был прицеплен, резолвнулся, колбек от then упал в микротаски
// setTimeout(() => console.log('5')); // setTimeout выполнится синхронно, коллбек будет отдан браузеру для добавления в очередь макротасок
// console.log('6'); // синхронный код

// к этому моменту остались только макротаски.
// call stack пустой, микротаски все выполнены, можно приниматься за макро. первым злогируется "5", так как у нее 0 задержка, вторым - "2", так как вторым аргументом передана 1 